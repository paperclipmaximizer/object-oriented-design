---
annotation-target: objectorienteddesignnotes.pdf
---

















>%%
>```annotation-json
>{"created":"2023-08-23T02:58:13.967Z","updated":"2023-08-23T02:58:13.967Z","document":{"title":"Object-Oriented Design_Course Notes","link":[{"href":"urn:x-pdf:7da4c24ac0cc18f7edff6f0532b3b8e5"},{"href":"vault:/literature/OOP Design/objectorienteddesignnotes.pdf"}],"documentFingerprint":"7da4c24ac0cc18f7edff6f0532b3b8e5"},"uri":"vault:/literature/OOP Design/objectorienteddesignnotes.pdf","target":[{"source":"vault:/literature/OOP Design/objectorienteddesignnotes.pdf","selector":[{"type":"TextPositionSelector","start":123975,"end":124139},{"type":"TextQuoteSelector","exact":"Arrows indicate transitions from one state to another. Transitions  are  typically  triggered  by  an  event.  This  event  is generally described above the arrow. ","prefix":"bject is in a certain state.  • ","suffix":"  Each  transition  arrow  will "}]}]}
>```
>%%
>*%%HIGHLIGHT%%Arrows indicate transitions from one state to another. Transitions  are  typically  triggered  by  an  event.  This  event  is generally described above the arrow.*
>%%LINK%%[[#^2mr7jr7tr33|show annotation]]
>%%COMMENT%%
>
>%%TAGS%%
>
^2mr7jr7tr33


>%%
>```annotation-json
>{"created":"2023-08-23T02:58:21.245Z","updated":"2023-08-23T02:58:21.245Z","document":{"title":"Object-Oriented Design_Course Notes","link":[{"href":"urn:x-pdf:7da4c24ac0cc18f7edff6f0532b3b8e5"},{"href":"vault:/literature/OOP Design/objectorienteddesignnotes.pdf"}],"documentFingerprint":"7da4c24ac0cc18f7edff6f0532b3b8e5"},"uri":"vault:/literature/OOP Design/objectorienteddesignnotes.pdf","target":[{"source":"vault:/literature/OOP Design/objectorienteddesignnotes.pdf","selector":[{"type":"TextPositionSelector","start":124376,"end":124588},{"type":"TextQuoteSelector","exact":"A circle with a filled circle inside indicates termination. Termination  represents  an  object  being  destroyed  or  the process being completed. Not all diagrams have a termination—some may run continuously.  ","prefix":"s and the condition is true.  • ","suffix":" State  diagrams  can  be  usefu"}]}]}
>```
>%%
>*%%HIGHLIGHT%%A circle with a filled circle inside indicates termination. Termination  represents  an  object  being  destroyed  or  the process being completed. Not all diagrams have a termination—some may run continuously.*
>%%LINK%%[[#^wsu1nksnfg|show annotation]]
>%%COMMENT%%
>
>%%TAGS%%
>
^wsu1nksnfg


>%%
>```annotation-json
>{"created":"2023-08-23T02:58:29.096Z","updated":"2023-08-23T02:58:29.096Z","document":{"title":"Object-Oriented Design_Course Notes","link":[{"href":"urn:x-pdf:7da4c24ac0cc18f7edff6f0532b3b8e5"},{"href":"vault:/literature/OOP Design/objectorienteddesignnotes.pdf"}],"documentFingerprint":"7da4c24ac0cc18f7edff6f0532b3b8e5"},"uri":"vault:/literature/OOP Design/objectorienteddesignnotes.pdf","target":[{"source":"vault:/literature/OOP Design/objectorienteddesignnotes.pdf","selector":[{"type":"TextPositionSelector","start":125177,"end":125316},{"type":"TextQuoteSelector","exact":".  They  can also  help  create  tests—knowing  the  different  states  of  a  system  can help ensure that tests are complete and correct.","prefix":"ition  that  was  unplanned  for","suffix":"   Model Checking In  addition  "}]}]}
>```
>%%
>*%%HIGHLIGHT%%.  They  can also  help  create  tests—knowing  the  different  states  of  a  system  can help ensure that tests are complete and correct.*
>%%LINK%%[[#^qk114z375u|show annotation]]
>%%COMMENT%%
>
>%%TAGS%%
>
^qk114z375u


>%%
>```annotation-json
>{"created":"2023-08-23T02:58:36.920Z","updated":"2023-08-23T02:58:36.920Z","document":{"title":"Object-Oriented Design_Course Notes","link":[{"href":"urn:x-pdf:7da4c24ac0cc18f7edff6f0532b3b8e5"},{"href":"vault:/literature/OOP Design/objectorienteddesignnotes.pdf"}],"documentFingerprint":"7da4c24ac0cc18f7edff6f0532b3b8e5"},"uri":"vault:/literature/OOP Design/objectorienteddesignnotes.pdf","target":[{"source":"vault:/literature/OOP Design/objectorienteddesignnotes.pdf","selector":[{"type":"TextPositionSelector","start":125415,"end":125762},{"type":"TextQuoteSelector","exact":" it  is  important  to  know  techniques  for  verifying  the  system. Some  of  these  techniques  include  unit  testing,  beta  testing,  and simulations. Another one such technique is model  checking, which is a systematic check of your system’s state model in all its possible states. Model checking helps find errors that other tests cannot.","prefix":" designing  a  software system, ","suffix":"   In  model  checking,  you  ch"}]}]}
>```
>%%
>*%%HIGHLIGHT%%it  is  important  to  know  techniques  for  verifying  the  system. Some  of  these  techniques  include  unit  testing,  beta  testing,  and simulations. Another one such technique is model  checking, which is a systematic check of your system’s state model in all its possible states. Model checking helps find errors that other tests cannot.*
>%%LINK%%[[#^9w85dt1xy7g|show annotation]]
>%%COMMENT%%
>
>%%TAGS%%
>
^9w85dt1xy7g


>%%
>```annotation-json
>{"created":"2023-08-23T02:58:42.176Z","updated":"2023-08-23T02:58:42.176Z","document":{"title":"Object-Oriented Design_Course Notes","link":[{"href":"urn:x-pdf:7da4c24ac0cc18f7edff6f0532b3b8e5"},{"href":"vault:/literature/OOP Design/objectorienteddesignnotes.pdf"}],"documentFingerprint":"7da4c24ac0cc18f7edff6f0532b3b8e5"},"uri":"vault:/literature/OOP Design/objectorienteddesignnotes.pdf","target":[{"source":"vault:/literature/OOP Design/objectorienteddesignnotes.pdf","selector":[{"type":"TextPositionSelector","start":126426,"end":126797},{"type":"TextQuoteSelector","exact":"magine software that has a rule not to produce a deadlock. Deadlock  is  a  situation  where  the  system  cannot  continue  because two  tasks  are  waiting  for  the  same  resource.  The  model  checker would  simulate  the  different  states  that  could  occur  in  your  system, and  if  a  deadlock  was  possible,  it  would  provide  details  of  this violation.","prefix":"ring testing of the software.  I","suffix":"   Let us go through the process"}]}]}
>```
>%%
>*%%HIGHLIGHT%%magine software that has a rule not to produce a deadlock. Deadlock  is  a  situation  where  the  system  cannot  continue  because two  tasks  are  waiting  for  the  same  resource.  The  model  checker would  simulate  the  different  states  that  could  occur  in  your  system, and  if  a  deadlock  was  possible,  it  would  provide  details  of  this violation.*
>%%LINK%%[[#^rcgnglwv4z|show annotation]]
>%%COMMENT%%
>
>%%TAGS%%
>
^rcgnglwv4z


>%%
>```annotation-json
>{"created":"2023-08-23T02:58:47.165Z","updated":"2023-08-23T02:58:47.165Z","document":{"title":"Object-Oriented Design_Course Notes","link":[{"href":"urn:x-pdf:7da4c24ac0cc18f7edff6f0532b3b8e5"},{"href":"vault:/literature/OOP Design/objectorienteddesignnotes.pdf"}],"documentFingerprint":"7da4c24ac0cc18f7edff6f0532b3b8e5"},"uri":"vault:/literature/OOP Design/objectorienteddesignnotes.pdf","target":[{"source":"vault:/literature/OOP Design/objectorienteddesignnotes.pdf","selector":[{"type":"TextPositionSelector","start":126860,"end":127019},{"type":"TextQuoteSelector","exact":"Model checkers begin by generating a state model from your code. A  state  model  is  an  abstract  state  machine  that  can  be  in  one  of various states. ","prefix":"s for model checking software.  ","suffix":"The model checker then checks th"}]}]}
>```
>%%
>*%%HIGHLIGHT%%Model checkers begin by generating a state model from your code. A  state  model  is  an  abstract  state  machine  that  can  be  in  one  of various states.*
>%%LINK%%[[#^tlplg490ie|show annotation]]
>%%COMMENT%%
>
>%%TAGS%%
>
^tlplg490ie


>%%
>```annotation-json
>{"created":"2023-08-23T02:59:32.730Z","updated":"2023-08-23T02:59:32.730Z","document":{"title":"Object-Oriented Design_Course Notes","link":[{"href":"urn:x-pdf:7da4c24ac0cc18f7edff6f0532b3b8e5"},{"href":"vault:/literature/OOP Design/objectorienteddesignnotes.pdf"}],"documentFingerprint":"7da4c24ac0cc18f7edff6f0532b3b8e5"},"uri":"vault:/literature/OOP Design/objectorienteddesignnotes.pdf","target":[{"source":"vault:/literature/OOP Design/objectorienteddesignnotes.pdf","selector":[{"type":"TextPositionSelector","start":127337,"end":128520},{"type":"TextQuoteSelector","exact":"There are three different phases in model checking.   The  first  is  the  modelling  phase.  During  this  phase,  the  model description  is  entered  in  the  same  programming  languages  as  the system.  Any  desired  properties  are  also  described.  This  phase  also performs sanity checks. Sanity checks are quick checks that should be  easy  to  do,  as  they  come  from  clear  and  simple  logic.  It  is beneficial to test for these simple errors before using model checkers,  so  the  focus  can  be  on  specifying  the  more  complex properties to check. Sanity checks might include something as simple as turning the system on and off.   The second phase is the running phase. The running phase is when the  model  checker  is  run  to  see  how  the  model  conforms  to  the desired properties described in the modelling phase.   The third and final phase is the analysis  phase. This phase is when all  desired  properties  are  checked  to  be  satisfied,  and  if  there  are any  violations.  Violations  are  called  counterexamples.  The  model checker  should  provide  descriptions  of  violations  in  the  system,  so you can analyze how they occurred.","prefix":"80 Object-Oriented Design | 80  ","suffix":"   Information  provided  by  th"}]}]}
>```
>%%
>*%%HIGHLIGHT%%There are three different phases in model checking.   The  first  is  the  modelling  phase.  During  this  phase,  the  model description  is  entered  in  the  same  programming  languages  as  the system.  Any  desired  properties  are  also  described.  This  phase  also performs sanity checks. Sanity checks are quick checks that should be  easy  to  do,  as  they  come  from  clear  and  simple  logic.  It  is beneficial to test for these simple errors before using model checkers,  so  the  focus  can  be  on  specifying  the  more  complex properties to check. Sanity checks might include something as simple as turning the system on and off.   The second phase is the running phase. The running phase is when the  model  checker  is  run  to  see  how  the  model  conforms  to  the desired properties described in the modelling phase.   The third and final phase is the analysis  phase. This phase is when all  desired  properties  are  checked  to  be  satisfied,  and  if  there  are any  violations.  Violations  are  called  counterexamples.  The  model checker  should  provide  descriptions  of  violations  in  the  system,  so you can analyze how they occurred.*
>%%LINK%%[[#^ui8s39g1t6l|show annotation]]
>%%COMMENT%%
>
>%%TAGS%%
>
^ui8s39g1t6l
